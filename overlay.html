<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracking Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .person-circle {
            position: absolute;
            border: 3px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease-out;
        }

        .hitparade-card {
            position: fixed;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            background: linear-gradient(90deg, #4f46e5 0%, #7c3aed 50%, #c026d3 100%);
            border-radius: 0 100px 100px 0;
            padding: 5px 5px 5px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5),
                        0 16px 48px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 460px;
            height: 190px;
            opacity: 0;
        }

        .hitparade-card.right-side {
            flex-direction: row;
            border-radius: 100px 0 0 100px;
            padding: 5px 20px 5px 5px;
        }

        .hitparade-photo {
            width: 180px;
            height: 180px;
            border: none;
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
        }

        .hitparade-photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .hitparade-name {
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            font-size: 68px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            flex: 1;
            text-align: center;
            padding: 0 15px;
        }

        @keyframes slideInFromLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToLeft {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(-120%);
                opacity: 0;
            }
        }

        @keyframes slideOutToRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        .hitparade-card.animate-left {
            animation: slideInFromLeft 0.6s ease-out forwards;
        }

        .hitparade-card.animate-right {
            animation: slideInFromRight 0.6s ease-out forwards;
        }

        .hitparade-card.hide-left {
            animation: slideOutToLeft 0.8s ease-in forwards;
        }

        .hitparade-card.hide-right {
            animation: slideOutToRight 0.8s ease-in forwards;
        }
    </style>
</head>
<body>
    <div id="snapshots-container"></div>
    <div id="overlay"></div>

    <script>
        const WS_URL = 'ws://localhost:8765';
        const overlay = document.getElementById('overlay');
        const snapshotsContainer = document.getElementById('snapshots-container');

        let ws = null;
        let personElements = new Map();
        let snapshotElements = new Map();
        let reconnectTimeout = null;
        let isHidingSnapshots = false;
        let circlesHidden = false;

        const CIRCLE_COLORS = [
            '#FFD700', // bright yellow (Earth)
            '#FF5500', // bright orange (Mercury)
            '#00DD00', // bright green (Venus)
            '#00AAFF', // bright blue (Uranus)
            '#00DDDD', // bright cyan (Neptune)
            '#FF44CC', // bright pink (Saturn)
            '#FF2222', // bright red (Mars)
            '#AA44FF', // bright violet (Pluto)
            '#FFAA00', // bright orange (Jupiter)
            '#FFEE00', // bright yellow (Sun)
        ];

        // Left side gradients (saturated)
        const LEFT_GRADIENTS = [
            'linear-gradient(180deg, #FFE033 0%, #FF9500 100%)',
            'linear-gradient(180deg, #44DD44 0%, #00CC44 100%)',
            'linear-gradient(180deg, #33CCDD 0%, #0099FF 100%)',
            'linear-gradient(180deg, #FF3333 0%, #FF5555 100%)',
            'linear-gradient(180deg, #FFAA00 0%, #DD7700 100%)',
        ];

        // Right side gradients (saturated)
        const RIGHT_GRADIENTS = [
            'linear-gradient(180deg, #FF5500 0%, #FF7744 100%)',
            'linear-gradient(180deg, #33AAFF 0%, #55BBFF 100%)',
            'linear-gradient(180deg, #FF44DD 0%, #FF66EE 100%)',
            'linear-gradient(180deg, #AA44FF 0%, #CC66FF 100%)',
            'linear-gradient(180deg, #FFDD00 0%, #FFEE44 100%)',
        ];

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) return;

            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                console.log('WebSocket connected');
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');

                // Clear all circles on disconnect
                personElements.forEach((el) => {
                    el.circle.remove();
                });
                personElements.clear();

                // Reconnect after 2 seconds
                reconnectTimeout = setTimeout(connect, 2000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'tracking') {
                        updateOverlay(data);
                    } else if (data.type === 'face_snapshots') {
                        updateFaceSnapshots(data);
                    } else if (data.type === 'clear_snapshots') {
                        clearAllSnapshots();
                    } else if (data.type === 'hide_snapshots') {
                        hideAllSnapshotsAnimated();
                    } else if (data.type === 'hide_circles') {
                        hideAllCircles();
                    } else if (data.type === 'show_circles') {
                        showCircles();
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };
        }

        function updateOverlay(data) {
            if (circlesHidden) return;

            const persons = data.persons || [];
            const currentIds = new Set(persons.map(p => String(p.id)));

            // Remove elements for persons no longer tracked
            const toDelete = [];
            personElements.forEach((el, id) => {
                if (!currentIds.has(id)) {
                    el.circle.remove();
                    toDelete.push(id);
                }
            });
            toDelete.forEach(id => personElements.delete(id));

            // Update or create elements for each person
            persons.forEach((person, index) => {
                const personId = String(person.id);
                let el = personElements.get(personId);

                if (!el) {
                    // Create new circle element
                    const circle = document.createElement('div');
                    circle.className = 'person-circle';
                    circle.dataset.personId = personId;

                    // Assign color based on person ID
                    const colorIndex = person.id % CIRCLE_COLORS.length;
                    const color = CIRCLE_COLORS[colorIndex];
                    circle.style.borderColor = color;

                    overlay.appendChild(circle);

                    el = { circle };
                    personElements.set(personId, el);
                }

                // Calculate position and size in viewport coordinates
                const viewWidth = window.innerWidth;
                const viewHeight = window.innerHeight;

                const cx = person.center.x * viewWidth;
                const cy = person.center.y * viewHeight;

                // Calculate bbox dimensions
                const bboxWidth = person.bbox.width * viewWidth;
                const bboxHeight = person.bbox.height * viewHeight;
                // Circle that circumscribes the face bbox (diameter = diagonal) + 20% padding
                const diameter = Math.sqrt(bboxWidth * bboxWidth + bboxHeight * bboxHeight) * 1.2;

                // Update circle position and size
                el.circle.style.left = `${cx}px`;
                el.circle.style.top = `${cy}px`;
                el.circle.style.width = `${diameter}px`;
                el.circle.style.height = `${diameter}px`;
            });

        }

        function calculateSnapshotPosition(position) {
            const CARD_HEIGHT = 190; // px
            const MARGIN = 0; // px from edge
            const LEVEL_SPACING = 210; // px vertical spacing between cards

            let top, left, right;

            // Calculate vertical position based on level
            // Level 0 = center, Level 1 = below center, Level 2 = further below, etc.
            const centerY = window.innerHeight / 2;
            top = centerY - (CARD_HEIGHT / 2) + (position.level * LEVEL_SPACING);

            // Calculate horizontal position based on side
            if (position.side === 'left') {
                left = MARGIN;
                right = 'auto';
            } else {
                left = 'auto';
                right = MARGIN;
            }

            return { top, left, right };
        }

        function clearAllSnapshots() {
            console.log('Clearing all snapshots from overlay');
            // Remove all snapshot cards
            snapshotElements.forEach((card) => {
                card.remove();
            });
            snapshotElements.clear();
        }

        function hideAllCircles() {
            console.log('Hiding all tracking circles');
            circlesHidden = true;
            // Remove all person circles
            personElements.forEach((el) => {
                el.circle.remove();
            });
            personElements.clear();
        }

        function showCircles() {
            console.log('Enabling tracking circles');
            circlesHidden = false;
        }

        function hideAllSnapshotsAnimated() {
            console.log('Hiding all snapshots with animation');
            if (isHidingSnapshots) {
                return;
            }
            isHidingSnapshots = true;
            // Animate each card sliding off screen based on its side
            snapshotElements.forEach((card) => {
                // Determine which side the card is on
                const isRightSide = card.classList.contains('right-side');
                const animationClass = isRightSide ? 'hide-right' : 'hide-left';

                // Add animation class
                card.classList.remove('animate-left', 'animate-right');
                card.style.animationDelay = '0s';
                card.classList.add(animationClass);

                // Remove card after animation completes (800ms)
                setTimeout(() => {
                    card.remove();
                }, 800);
            });

            // Clear the map after animations complete
            setTimeout(() => {
                snapshotElements.clear();
                isHidingSnapshots = false;
            }, 800);
        }

        function updateFaceSnapshots(data) {
            if (isHidingSnapshots) {
                return;
            }
            if (!data.snapshots || data.snapshots.length === 0) {
                return;
            }

            const currentIds = new Set(data.snapshots.map(s => String(s.track_id)));

            // Remove snapshots that are no longer present
            const toDelete = [];
            snapshotElements.forEach((card, id) => {
                if (!currentIds.has(id)) {
                    card.remove();
                    toDelete.push(id);
                }
            });
            toDelete.forEach(id => snapshotElements.delete(id));

            // Update or create snapshots
            data.snapshots.forEach(snapshot => {
                const trackId = String(snapshot.track_id);
                let card = snapshotElements.get(trackId);
                const isNewCard = !card;

                if (!card) {
                    // Create new hitparade card
                    card = document.createElement('div');
                    card.className = 'hitparade-card';

                    // Create photo container
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'hitparade-photo';
                    const img = document.createElement('img');
                    img.alt = `Face ${trackId}`;
                    photoDiv.appendChild(img);

                    // Create planet name
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'hitparade-name';

                    // Add elements to card
                    card.appendChild(photoDiv);
                    card.appendChild(nameDiv);

                    snapshotsContainer.appendChild(card);
                    snapshotElements.set(trackId, card);
                }

                // Update image
                const img = card.querySelector('.hitparade-photo img');
                img.src = snapshot.image;

                // Update planet name
                const nameDiv = card.querySelector('.hitparade-name');
                nameDiv.textContent = snapshot.planet || '';

                // Set card direction based on side
                if (snapshot.position.side === 'right') {
                    card.classList.add('right-side');
                } else {
                    card.classList.remove('right-side');
                }

                // Calculate and apply position
                const pos = calculateSnapshotPosition(snapshot.position);
                card.style.top = `${pos.top}px`;
                card.style.left = pos.left === 'auto' ? 'auto' : `${pos.left}px`;
                card.style.right = pos.right === 'auto' ? 'auto' : `${pos.right}px`;

                // Add animation and color for new cards
                if (isNewCard && snapshot.position.index !== undefined) {
                    const animationClass = snapshot.position.side === 'left' ? 'animate-left' : 'animate-right';
                    const delay = snapshot.position.index * 0.5; // 500ms delay between cards
                    card.style.animationDelay = `${delay}s`;
                    card.classList.add(animationClass);

                    // Assign gradient based on side and position
                    const sideIndex = Math.floor(snapshot.position.index / 2);
                    if (snapshot.position.side === 'left') {
                        card.style.background = LEFT_GRADIENTS[sideIndex % LEFT_GRADIENTS.length];
                    } else {
                        card.style.background = RIGHT_GRADIENTS[sideIndex % RIGHT_GRADIENTS.length];
                    }
                }
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            // Elements will be repositioned on next update
        });

        // Start connection
        connect();
    </script>
</body>
</html>
